{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/main.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n'use strict'\n\n\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'DESQL'\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\ninfo                      = CND.get_logger 'info',      badge\nurge                      = CND.get_logger 'urge',      badge\nhelp                      = CND.get_logger 'help',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\necho                      = CND.echo.bind CND\n#...........................................................................................................\ntypes                     = new ( require 'intertype' ).Intertype\n{ isa\n  equals\n  type_of\n  validate\n  validate_list_of }      = types.export()\nGUY                       = require 'guy'\n{ DBay }                  = require 'dbay'\n{ SQL }                   = DBay\nto_snake_case             = require 'just-snake-case'\n{ antlr: ANTLR          } = require 'rhombic'\n\n\n#===========================================================================================================\n#\n#-----------------------------------------------------------------------------------------------------------\nclass @Desql\n\n  #---------------------------------------------------------------------------------------------------------\n  constructor: ( P... ) ->\n    throw new Error \"^345^ configuration settings not supported\" if P.length > 0\n    @db = new DBay()\n    @_procure_infrastructure()\n    @_compile_sql()\n    return undefined\n\n  #---------------------------------------------------------------------------------------------------------\n  _procure_infrastructure: ->\n    ### TAINT check if tables exist ###\n    @db.create_stdlib()\n    #.......................................................................................................\n    @db SQL\"\"\"\n      create table queries (\n          qid     integer not null primary key,\n          length  integer generated always as ( length( query ) ),\n          query   text    not null );\"\"\"\n    #.......................................................................................................\n    @db SQL\"\"\"\n      create table raw_nodes (\n          qid     integer not null,\n          id      integer not null,\n          xtra    integer not null default 1,\n          upid    integer,\n          type    text    not null,\n          pos1    integer,\n          pos2    integer,\n          lnr1    integer,\n          col1    integer,\n          lnr2    integer,\n          col2    integer,\n        primary key ( qid, id, xtra ),\n        foreign key ( qid ) references queries\n        -- foreign key ( upid ) references raw_nodes ( id ) DEFERRABLE INITIALLY DEFERRED\n        );\"\"\"\n    #.......................................................................................................\n    @db SQL\"\"\"\n      create view _coverage_1 as select\n          n.qid                                                 as qid,\n          n.id                                                  as id,\n          n.xtra                                                as xtra,\n          n.pos1                                                as pos1,\n          n.pos2                                                as pos2,\n          substring( q.query, n.pos1, n.pos2 - n.pos1 + 1 )     as txt\n        from raw_nodes as n\n        join queries as q using ( qid )\n        where pos1 is not null;\"\"\"\n    #.......................................................................................................\n    @db SQL\"\"\"\n      create view _coverage_holes_1 as select\n          *,\n          pos2 + 1                                              as nxt_pos1,\n          lead( pos1 ) over w - 1                               as nxt_pos2\n        from _coverage_1 as c\n        window w as ( partition by qid order by pos1 );\"\"\"\n    #.......................................................................................................\n    @db SQL\"\"\"\n      create view _coverage_holes as select\n          c.qid                                                           as qid,\n          c.id                                                            as id,\n          c.xtra                                                          as xtra,\n          c.nxt_pos1                                                      as pos1,\n          c.nxt_pos2                                                      as pos2,\n          substring( q.query, c.nxt_pos1, c.nxt_pos2 - c.nxt_pos1 + 1 )   as txt\n        from _coverage_holes_1 as c\n        join queries as q using ( qid )\n        where c.nxt_pos1 <= c.nxt_pos2\n      ;\"\"\"\n    #.......................................................................................................\n    @db SQL\"\"\"\n      create view coverage as select\n          *\n        from _coverage_1\n        order by pos1;\"\"\"\n    #.......................................................................................................\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _compile_sql: ->\n    GUY.props.hide @, 'statements',\n      #.....................................................................................................\n      insert_query: @db.prepare_insert\n        into:         'queries'\n        exclude:      [ 'qid', ]\n        returning:    '*'\n      #.....................................................................................................\n      insert_special_node: @db.prepare_insert\n        into:         'raw_nodes'\n        returning:    '*'\n      #.....................................................................................................\n      insert_regular_node: @db.prepare SQL\"\"\"\n        insert into raw_nodes ( qid, id, upid, type, pos1, pos2, lnr1, col1, lnr2, col2 )\n          values (\n            $qid,\n            ( select coalesce( max( id ), 0 ) + 1 as id from raw_nodes ),\n            $upid, $type, $pos1, $pos2, $lnr1, $col1, $lnr2, $col2 )\n          returning *;\"\"\"\n      #.....................................................................................................\n      insert_start_node: @db.prepare SQL\"\"\"\n        insert into raw_nodes ( qid, id, xtra, upid, type, pos1, pos2, lnr1, col1, lnr2, col2 )\n          values (\n            $qid, 1, 1, null, 'start', 0, 1, 0, 0, 0, 0 )\n          returning *;\"\"\"\n      #.....................................................................................................\n      insert_stop_node: @db.prepare SQL\"\"\"\n        insert into raw_nodes ( qid, id, xtra, upid, type, pos1, pos2, lnr1, col1, lnr2, col2 )\n          values (\n            $qid,\n            ( select coalesce( max( id ), 0 ) + 1 as id from raw_nodes ),\n            1, null, 'stop',\n            -- ### TAINT would use CET but fails with \"no such column: v.length\"\n            ( select length + 1 from queries where qid = $qid ),\n            ( select length     from queries where qid = $qid ),\n            0, 0, 0, 0 )\n          returning *;\"\"\"\n      #.....................................................................................................\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  parse: ( query ) ->\n    parser_cfg      =\n      doubleQuotedIdentifier: true\n    antlr           = { children: [ ( ANTLR.parse query, parser_cfg ).tree, ], }\n    R               = { type: 'query', nodes: [], }\n    { qid, }        = @statements.insert_query.get { query, }\n    R.nodes.push @statements.insert_start_node.get { qid, }\n    @_build_tree qid, query, antlr, null, 0, R\n    R.nodes.push @statements.insert_stop_node.get { qid, }\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  _build_tree: ( qid, query, antlr, parent, level, tree ) ->\n    for branch in antlr.children\n      type            = @_type_of_antler_node branch\n      position        = @_position_from_branch branch\n      txt             = null\n      upid            = parent?.id ? null\n      flat_node       = { qid, upid, type, position..., }\n      @db SQL\"savepoint svp_name;\"\n      flat_node       = @statements.insert_regular_node.get flat_node\n      node            = { flat_node..., nodes: [], }\n      if branch.children?\n        @_build_tree qid, query, branch, flat_node, level + 1, node\n      if ( node.type isnt 'terminal' ) and ( node.nodes.length is 0 )\n        @db SQL\"rollback transaction to savepoint svp_name;\" # , { svp_name, }\n      else\n        @db SQL\"release svp_name;\"\n        tree.nodes.push node\n      delete node.nodes if node.nodes.length is 0\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _type_of_antler_node: ( node ) ->\n    R = node.constructor.name\n    R = R.replace /(Node|Context)$/, ''\n    R = to_snake_case R\n    return R\n\n  #---------------------------------------------------------------------------------------------------------\n  _position_from_branch: ( branch ) ->\n    if branch._symbol?\n      pos1  = branch._symbol.start + 1\n      lnr1  = branch._symbol._line\n      col1  = branch._symbol._charPositionInLine + 1\n      pos2  = branch._symbol.stop  + 1\n      lnr2  = branch._symbol._line\n      col2  = branch._symbol._charPositionInLine + 1 + branch._symbol.stop - branch._symbol.start\n    else\n      pos1  = null\n      lnr1  = null\n      col1  = null\n      pos2  = null\n      lnr2  = null\n      col2  = null\n    return { pos1, lnr1, col1, pos2, lnr2, col2, }\n\n"
  ]
}